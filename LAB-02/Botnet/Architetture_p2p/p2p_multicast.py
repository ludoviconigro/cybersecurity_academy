#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
p2p_multicast_vmware_buffered_sync_stderr.py

Versione del P2P demo dove i log generati dalle thread server/discovery sono
inviati a stderr (server_log) mentre la REPL usa log buffer (buffered_log)
che viene flushato prima del prompt.

Esempi:
  - esecuzione normale (stderr e stdout sullo stesso terminale):
      python3 p2p_multicast_vmware_buffered_sync_stderr.py --host 192.168.58.139 --port 8000

  - separare i log server in file:
      python3 p2p_multicast_vmware_buffered_sync_stderr.py --host 192.168.58.139 --port 8000 2>server.log

  - mandare stdout su /dev/null e tenere solo server log:
      python3 p2p_multicast_vmware_buffered_sync_stderr.py --host 192.168.58.139 --port 8000 1>/dev/null 2>server.log
"""
import argparse
import queue
import socket
import socketserver
import threading
import time
import sys
from typing import Dict, Tuple, Optional, List

# ---------------- Configuration ------------------------------------------------
MCAST_GRP = "239.255.0.1"
MCAST_PORT = 9999
MCAST_TTL = 1
DISCOVER_INTERVAL = 5.0
IDLE_TIMEOUT = 300
DEFAULT_SEND_WAIT_TIMEOUT = 5.0

ConnID = int
Addr = Tuple[str, int]

DEFAULT_BOOTSTRAP_IPS = [
    "192.168.58.143",
    "192.168.58.2",
    "192.168.58.1",
    "192.168.58.137",
    "192.168.58.139",
    "192.168.58.140",
    "192.168.58.254",
]
DEFAULT_BOOTSTRAP_PORT = 8000

# ---------------- Logging helpers ---------------------------------------------
LOG_PROMPT = "p2p-mcast> "

# buffered logs for REPL (flush before prompt)
_buffer_lock = threading.Lock()
_buffered_logs: List[str] = []

# lock used when writing immediately to stderr/stdout
_write_lock = threading.Lock()

def buffered_log(msg: str) -> None:
    """Append a timestamped message to the buffer (thread-safe).
    These messages will be flushed by the REPL before showing the prompt."""
    ts = time.strftime("%H:%M:%S")
    entry = f"[{ts}] {msg}"
    with _buffer_lock:
        _buffered_logs.append(entry)

def flush_logs() -> None:
    """Print and clear all buffered logs to stdout. Call from REPL before input()."""
    with _buffer_lock:
        if not _buffered_logs:
            return
        to_print = _buffered_logs[:]
        _buffered_logs.clear()
    with _write_lock:
        for line in to_print:
            # ensure these go to stdout (so they get flushed before prompt)
            sys.stdout.write(line + "\n")
        sys.stdout.flush()

def server_log(msg: str) -> None:
    """Immediate, thread-safe print to stderr for server-side 'refresh' logs.
    Use this for messages generated by server/listener threads so they can be redirected.
    WARNING: printing to stderr will still appear on the terminal unless redirected."""
    ts = time.strftime("%H:%M:%S")
    entry = f"[{ts}] {msg}"
    with _write_lock:
        # write to stderr directly
        sys.stderr.write(entry + "\n")
        sys.stderr.flush()

def log_critical(msg: str) -> None:
    """Critical message printed immediately to stdout (rare)."""
    with _write_lock:
        sys.stdout.write("\n" + msg + "\n")
        sys.stdout.flush()

# ---------------- Connection registry -----------------------------------------
class ConnectionRegistry:
    def __init__(self):
        self._lock = threading.Lock()
        self._next_id = 1
        self._conns: Dict[ConnID, Tuple[socket.socket, Addr, bool, float]] = {}
        self._msg_queues: Dict[ConnID, "queue.Queue[str]"] = {}

    def add(self, sock: socket.socket, addr: Addr, incoming: bool) -> ConnID:
        with self._lock:
            cid = self._next_id
            self._next_id += 1
            self._conns[cid] = (sock, addr, incoming, time.time())
            self._msg_queues[cid] = queue.Queue()
            return cid

    def touch(self, cid: ConnID) -> None:
        with self._lock:
            if cid in self._conns:
                sock, addr, incoming, _ = self._conns[cid]
                self._conns[cid] = (sock, addr, incoming, time.time())

    def remove(self, cid: ConnID) -> None:
        with self._lock:
            if cid in self._conns:
                sock, _, _, _ = self._conns.pop(cid)
                self._msg_queues.pop(cid, None)
                try:
                    sock.close()
                except Exception:
                    pass

    def items(self):
        with self._lock:
            return list(self._conns.items())

    def get(self, cid: ConnID):
        with self._lock:
            return self._conns.get(cid)

    def find_by_addr(self, addr: Addr):
        with self._lock:
            for cid, (_, a, _, _) in self._conns.items():
                if a == addr:
                    return cid
        return None

    def find_idle(self, idle_threshold: float):
        now = time.time()
        idle = []
        with self._lock:
            for cid, (_, addr, _, last) in self._conns.items():
                if now - last > idle_threshold:
                    idle.append((cid, addr))
        return idle

    def push_msg(self, cid: ConnID, msg: str) -> None:
        q = None
        with self._lock:
            q = self._msg_queues.get(cid)
        if q:
            try:
                q.put_nowait(msg)
            except queue.Full:
                pass

    def pop_msg(self, cid: ConnID, timeout: Optional[float] = None) -> Optional[str]:
        q = None
        with self._lock:
            q = self._msg_queues.get(cid)
        if not q:
            return None
        try:
            return q.get(timeout=timeout)
        except queue.Empty:
            return None

# ---------------- TCP handler --------------------------------------------------
class P2PRequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        peer = getattr(self.server, "peer_instance", None)
        addr = self.client_address
        tname = threading.current_thread().name

        if peer is None:
            server_log(f"[{tname}] Handler senza riferimento al Peer; chiudo.")
            return

        cid = peer.registry.add(self.request, addr, incoming=True)
        # server-side event -> stderr (immediate)
        server_log(f"[{tname}] Connessione IN registrata: id={cid} addr={addr}")

        try:
            while True:
                data = self.request.recv(4096)
                if not data:
                    break
                peer.registry.touch(cid)
                try:
                    message = data.decode("utf-8", errors="replace").rstrip("\n")
                except Exception:
                    message = repr(data)
                # push message to queue for any waiting send_and_wait
                peer.registry.push_msg(cid, message)
                # server event to stderr
                server_log(f"[{tname}] Ricevuto da {addr} (id={cid}): {message}")
                # Echo uppercase
                response = message.upper()
                try:
                    self.request.sendall(response.encode("utf-8"))
                except Exception as e:
                    server_log(f"[{tname}] Errore invio a id={cid}: {e}")
                    break
        except ConnectionResetError:
            server_log(f"[{tname}] Connessione con {addr} interrotta.")
        except Exception as e:
            server_log(f"[{tname}] Errore gestione connessione {addr}: {e}")
        finally:
            server_log(f"[{tname}] Chiusura IN id={cid} addr={addr}")
            peer.registry.remove(cid)

# ---------------- Peer class --------------------------------------------------
class Peer:
    def __init__(
        self,
        host: str,
        port: int,
        bootstrap: Optional[List[Tuple[str, int]]] = None,
        mcast_group: str = MCAST_GRP,
        mcast_port: int = MCAST_PORT,
        discover_interval: float = DISCOVER_INTERVAL,
        idle_timeout: int = IDLE_TIMEOUT,
        send_wait_timeout: float = DEFAULT_SEND_WAIT_TIMEOUT,
    ):
        self.host = host
        self.port = port
        self.registry = ConnectionRegistry()
        self.server = None
        self._server_thread = None
        self._stop_event = threading.Event()

        self.mcast_group = mcast_group
        self.mcast_port = mcast_port
        self._mcast_sock = None
        self._mcast_thread = None
        self._announcer_thread = None
        self.discover_interval = discover_interval

        self.bootstrap = bootstrap or []
        self.idle_timeout = idle_timeout
        self._idle_thread = None

        self.send_wait_timeout = float(send_wait_timeout)

    def start_server(self):
        class _Server(socketserver.ThreadingTCPServer):
            allow_reuse_address = True

        try:
            self.server = _Server((self.host, self.port), P2PRequestHandler)
        except Exception as e:
            buffered_log(f"[server] Impossibile avviare server su {self.host}:{self.port}: {e}")
            raise
        setattr(self.server, "peer_instance", self)

        def serve():
            # server start is a server-side event -> stderr
            server_log(f"[server] Peer in ascolto su {self.host}:{self.port}")
            try:
                self.server.serve_forever(poll_interval=0.5)
            except Exception as e:
                server_log(f"[server] Terminated: {e}")

        self._server_thread = threading.Thread(target=serve, name="p2p-server", daemon=True)
        self._server_thread.start()

    def stop_server(self):
        if self.server:
            try:
                self.server.shutdown()
                self.server.server_close()
            except Exception:
                pass
        self._stop_event.set()
        for cid, (sock, _, _, _) in self.registry.items():
            try:
                sock.close()
            except Exception:
                pass
            self.registry.remove(cid)

    def _should_initiate(self, remote: Addr) -> bool:
        return (self.host, self.port) < remote

    def connect(self, ip: str, port: int, timeout: float = 3.0) -> Optional[ConnID]:
        if ip == self.host and port == self.port:
            raise ConnectionError("Tentativo connessione verso se stessi; ignorato.")
        if self.registry.find_by_addr((ip, port)) is not None:
            return None
        if not self._should_initiate((ip, port)):
            raise ConnectionError("Regola anti-duplicato: non avviare connessione verso peer con ordine minore/uguale.")
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        try:
            sock.connect((ip, port))
        except Exception as e:
            sock.close()
            raise ConnectionError(f"Connessione fallita a {ip}:{port}: {e}")
        cid = self.registry.add(sock, (ip, port), incoming=False)
        t = threading.Thread(target=self._listen_outgoing, args=(cid,), name=f"out-{cid}", daemon=True)
        t.start()
        # connection established -> server-side event
        server_log(f"[peer] Connessione OUT stabilita id={cid} addr={(ip,port)}")
        return cid

    def _listen_outgoing(self, cid: ConnID):
        entry = self.registry.get(cid)
        if not entry:
            return
        sock, addr, _, _ = entry
        tname = threading.current_thread().name
        try:
            while not self._stop_event.is_set():
                try:
                    data = sock.recv(4096)
                except socket.timeout:
                    continue
                except OSError:
                    break
                if not data:
                    break
                self.registry.touch(cid)
                try:
                    msg = data.decode("utf-8", errors="replace").rstrip("\n")
                except Exception:
                    msg = repr(data)
                # push to queue and immediate server log (stderr)
                self.registry.push_msg(cid, msg)
                server_log(f"[{tname}] Ricevuto da {addr} (id={cid}): {msg}")
        except Exception as e:
            server_log(f"[{tname}] Errore ascolto id={cid}: {e}")
        finally:
            server_log(f"[{tname}] Connessione OUT id={cid} chiusa")
            self.registry.remove(cid)

    def send(self, cid: ConnID, message: str):
        entry = self.registry.get(cid)
        if not entry:
            raise KeyError("Connessione non trovata")
        sock, addr, _, _ = entry
        try:
            sock.sendall(message.encode("utf-8"))
            self.registry.touch(cid)
        except Exception as e:
            raise ConnectionError(f"Invio fallito su {addr}: {e}")

    def send_and_wait(self, cid: ConnID, message: str, timeout: Optional[float] = None) -> Optional[str]:
        entry = self.registry.get(cid)
        if not entry:
            raise KeyError("Connessione id non trovata")
        sock, addr, _, _ = entry
        try:
            sock.sendall(message.encode("utf-8"))
            self.registry.touch(cid)
        except Exception as e:
            raise ConnectionError(f"Invio fallito su {addr}: {e}")
        use_to = timeout if (timeout is not None) else self.send_wait_timeout
        resp = self.registry.pop_msg(cid, timeout=use_to)
        return resp

    def broadcast(self, message: str):
        for cid, (sock, addr, _, _) in self.registry.items():
            try:
                sock.sendall(message.encode("utf-8"))
                self.registry.touch(cid)
            except Exception as e:
                server_log(f"[broadcast] Errore invio a {addr}: {e}")

    def list_peers(self):
        rows = []
        for cid, (sock, addr, incoming, last) in self.registry.items():
            rows.append((cid, addr, "in" if incoming else "out", int(time.time() - last)))
        return rows

    # ---------------- Multicast discovery ---------------------------------
    def _create_mcast_socket(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        except Exception:
            pass
        try:
            sock.bind(("", self.mcast_port))
        except Exception as e:
            sock.close()
            raise RuntimeError(f"Bind multicast fallito: {e}")
        try:
            mreq = socket.inet_aton(self.mcast_group) + socket.inet_aton(self.host)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
        except Exception as e:
            sock.close()
            raise RuntimeError(f"Join multicast su {self.host} fallito: {e}")
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, MCAST_TTL)
        sock.settimeout(1.0)
        return sock

    def start_discovery(self):
        try:
            self._mcast_sock = self._create_mcast_socket()
        except Exception as e:
            buffered_log(f"[mcast] Impossibile inizializzare multicast: {e}")
            return

        def listen():
            tn = threading.current_thread().name
            server_log(f"[{tn}] Ascolto multicast {self.mcast_group}:{self.mcast_port} iface={self.host}")
            while not self._stop_event.is_set():
                try:
                    data, addr = self._mcast_sock.recvfrom(1024)
                except socket.timeout:
                    continue
                except Exception as e:
                    server_log(f"[{tn}] Errore recvfrom: {e}")
                    break
                try:
                    text = data.decode("utf-8", errors="replace").strip()
                except Exception:
                    text = repr(data)
                parts = text.split()
                if len(parts) >= 3 and parts[0] == "DISCOVER":
                    peer_ip = parts[1]
                    try:
                        peer_port = int(parts[2])
                    except Exception:
                        continue
                    if peer_ip == self.host and peer_port == self.port:
                        continue
                    if self.registry.find_by_addr((peer_ip, peer_port)) is None:
                        if self._should_initiate((peer_ip, peer_port)):
                            server_log(f"[{tn}] Scoperto peer {peer_ip}:{peer_port} -> provo connessione")
                            try:
                                self.connect(peer_ip, peer_port)
                            except Exception as e:
                                server_log(f"[{tn}] Connessione fallita a {peer_ip}:{peer_port}: {e}")
                        else:
                            server_log(f"[{tn}] Scoperto peer {peer_ip}:{peer_port} -> attendo connessione IN (anti-duplica)")

        def announce():
            tn = threading.current_thread().name
            try:
                send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
                try:
                    send_sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF, socket.inet_aton(self.host))
                except Exception:
                    pass
                send_sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, MCAST_TTL)
                while not self._stop_event.is_set():
                    msg = f"DISCOVER {self.host} {self.port}"
                    try:
                        send_sock.sendto(msg.encode("utf-8"), (self.mcast_group, self.mcast_port))
                    except Exception as e:
                        server_log(f"[{tn}] Errore invio DISCOVER: {e}")
                    time.sleep(self.discover_interval)
            finally:
                try:
                    send_sock.close()
                except Exception:
                    pass

        self._mcast_thread = threading.Thread(target=listen, name="mcast-listener", daemon=True)
        self._announcer_thread = threading.Thread(target=announce, name="mcast-announcer", daemon=True)
        self._mcast_thread.start()
        self._announcer_thread.start()

        if self.bootstrap:
            t = threading.Thread(target=self._bootstrap_connect, name="bootstrap", daemon=True)
            t.start()

        self._idle_thread = threading.Thread(target=self._idle_monitor, name="idle-monitor", daemon=True)
        self._idle_thread.start()

    def _bootstrap_connect(self):
        for (ip, port) in self.bootstrap:
            if self._stop_event.is_set():
                return
            if ip == self.host and port == self.port:
                continue
            if self.registry.find_by_addr((ip, port)) is None and self._should_initiate((ip, port)):
                server_log(f"[bootstrap] Tentativo connessione a {ip}:{port}")
                try:
                    self.connect(ip, port)
                except Exception as e:
                    server_log(f"[bootstrap] Connessione a {ip}:{port} fallita: {e}")

    def _idle_monitor(self):
        while not self._stop_event.is_set():
            idle = self.registry.find_idle(self.idle_timeout)
            for cid, addr in idle:
                server_log(f"[idle-monitor] Connessione id={cid} addr={addr} idle>={self.idle_timeout}s -> chiudo")
                self.registry.remove(cid)
            time.sleep(5.0)

    def stop_discovery(self):
        self._stop_event.set()
        try:
            if self._mcast_sock:
                try:
                    mreq = socket.inet_aton(self.mcast_group) + socket.inet_aton(self.host)
                    self._mcast_sock.setsockopt(socket.IPPROTO_IP, socket.IP_DROP_MEMBERSHIP, mreq)
                except Exception:
                    pass
                try:
                    self._mcast_sock.close()
                except Exception:
                    pass
        except Exception:
            pass

# ---------------- REPL (buffered flush + send_and_wait) -----------------------
def repl(peer: Peer):
    help_text = (
        "Comandi disponibili:\n"
        "  connect <ip> <port>      - Apri connessione verso peer\n"
        "  peers                    - Lista connessioni (id, addr, in/out, idle_s)\n"
        "  send <id> <message>      - Invia messaggio a connessione specifica e attendi risposta\n"
        "  broadcast <message>      - Invia a tutte le connessioni\n"
        "  close <id>               - Chiudi connessione specifica\n"
        "  exit                     - Arresta server e termina\n"
        "  help                     - Mostra questo aiuto\n"
    )
    # print help directly (so user sees it immediately)
    print(help_text, end="\n")

    while True:
        # flush buffered logs before prompt (these come from buffered_log())
        flush_logs()

        try:
            raw = input(LOG_PROMPT).strip()
        except (EOFError, KeyboardInterrupt):
            print("\nUscita...")
            break

        if not raw:
            continue
        parts = raw.split(" ", 2)
        cmd = parts[0].lower()

        try:
            if cmd == "help":
                print(help_text)
            elif cmd == "connect" and len(parts) >= 3:
                ip = parts[1]
                try:
                    port = int(parts[2])
                except ValueError:
                    print("Porta non valida.")
                    continue
                try:
                    cid = peer.connect(ip, port)
                    print(f"Connesso: id={cid}")
                except Exception as e:
                    print(f"Errore connect: {e}")
            elif cmd == "peers":
                rows = peer.list_peers()
                if not rows:
                    print("Nessuna connessione attiva.")
                else:
                    for cid, addr, typ, idle in rows:
                        print(f"id={cid} addr={addr} type={typ} idle_s={idle}")
            elif cmd == "send" and len(parts) >= 3:
                try:
                    cid = int(parts[1])
                except ValueError:
                    print("ID non valido.")
                    continue
                message = parts[2]
                try:
                    resp = peer.send_and_wait(cid, message, timeout=None)
                    print("Messaggio inviato.")
                    if resp is None:
                        print(f"(Nessuna risposta entro {peer.send_wait_timeout}s; la risposta apparirÄ‚  al prossimo prompt)")
                    else:
                        print("Risposta:", resp)
                except Exception as e:
                    print(f"Errore invio: {e}")
            elif cmd == "broadcast" and len(parts) >= 2:
                message = raw[len("broadcast ") :]
                peer.broadcast(message)
                print("Broadcast inviato.")
            elif cmd == "close" and len(parts) >= 2:
                try:
                    cid = int(parts[1])
                except ValueError:
                    print("ID non valido.")
                    continue
                peer.registry.remove(cid)
                print(f"Connessione id={cid} chiusa.")
            elif cmd == "exit":
                break
            else:
                print("Comando non riconosciuto. Digita 'help'.")
        except Exception as e:
            print(f"Errore nel comando: {e}")

# ---------------- Helpers -----------------------------------------------------
def parse_bootstrap_arg(arg: Optional[str]):
    if not arg:
        return [(ip, DEFAULT_BOOTSTRAP_PORT) for ip in DEFAULT_BOOTSTRAP_IPS]
    pairs = []
    for part in arg.split(","):
        p = part.strip()
        if not p:
            continue
        if ":" in p:
            ip, pr = p.split(":", 1)
            try:
                port = int(pr)
            except ValueError:
                continue
        else:
            ip = p
            port = DEFAULT_BOOTSTRAP_PORT
        pairs.append((ip, port))
    return pairs

def get_local_ip(remote_host="8.8.8.8", remote_port=80):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect((remote_host, remote_port))
        ip = s.getsockname()[0]
    except Exception:
        ip = "127.0.0.1"
    finally:
        try:
            s.close()
        except Exception:
            pass
    return ip

def parse_args():
    p = argparse.ArgumentParser(description="P2P multicast (buffered logger + server->stderr)")
    p.add_argument("--host", "-H", default=None, help="Host bind IP (default auto-detected)")
    p.add_argument("--port", "-p", type=int, default=8000, help="Porta di ascolto (default 8000)")
    p.add_argument("--mcast", default=MCAST_GRP, help="Multicast group (default %(default)s)")
    p.add_argument("--mport", type=int, default=MCAST_PORT, help="Multicast port (default %(default)s)")
    p.add_argument("--bootstrap", default=None, help="Optional comma-separated bootstrap list ip:port (default uses embedded VMware IPs)")
    p.add_argument("--idle", type=int, default=IDLE_TIMEOUT, help="Idle timeout in seconds (default %(default)s)")
    p.add_argument("--send-timeout", type=float, default=DEFAULT_SEND_WAIT_TIMEOUT, help="Timeout send_and_wait in seconds (default %(default)s)")
    return p.parse_args()

# ---------------- Main -------------------------------------------------------
def main():
    args = parse_args()
    host = args.host if args.host else get_local_ip()
    port = args.port
    bootstrap = parse_bootstrap_arg(args.bootstrap)
    bootstrap = [(ip, pr) for (ip, pr) in bootstrap if not (ip == host and pr == port)]

    buffered_log(f"[main] Avvio peer su {host}:{port} (multicast {args.mcast}:{args.mport}) send_timeout={args.send_timeout}s")

    peer = Peer(
        host,
        port,
        bootstrap=bootstrap,
        mcast_group=args.mcast,
        mcast_port=args.mport,
        discover_interval=DISCOVER_INTERVAL,
        idle_timeout=args.idle,
        send_wait_timeout=args.send_timeout,
    )

    try:
        peer.start_server()
    except Exception as e:
        buffered_log(f"[main] Impossibile avviare server: {e}")
        flush_logs()
        sys.exit(1)

    peer.start_discovery()

    try:
        repl(peer)
    finally:
        buffered_log("[main] Arresto...")
        peer.stop_discovery()
        peer.stop_server()
        for cid, (sock, _, _, _) in peer.registry.items():
            try:
                sock.close()
            except Exception:
                pass
            peer.registry.remove(cid)
        flush_logs()
        print("Peer terminato.")

if __name__ == "__main__":
    main()
